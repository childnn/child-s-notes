并行: 多个程序互不影响, 同时执行 (同一时刻)  -- 多个人同时做多件事
并发: 多个程序在一段时间内,交替执行 -- 一个人 "同时" 做多件事

process: 进程.
thread: 线程, 轻量级进程(lightweight process).
现代操作系统把线程作为时序调度的基本单位.

write-once, run-anywhere.

deadlock 死锁
starvation 饥饿
livelock 活锁


线程的风险:
safe 安全危险.
    两个线程操作共享变量. -- 竞争条件(race condition).
    解决之一: synchronized 同步方法.
liveness failure 活跃度失败.
    一个活动进入某种它永远无法再继续执行的状态时, 活跃度失败就发生了.
     eg: 死循环中循环之后的代码; 多线程中, 线程 A 等待一个线程 B 独占的资源, B 永远不释放这个资源, A 将永远等待下去.
performance 性能.
     上下文切换: context switches.

共享: 一个变量可以被多个线程访问.
可变: 变量的值在其生命周期内可以改变.

在没有正确同步的情况下, 如果多个线程访问了同一个变量, 你的程序就存在隐患.
有 3 种方法修复它:
  1. 不要跨线程共享变量;
  2. 使状态变量为不可变的;
  3. 在任何访问状态变量的时候使用同步.

线程安全: 当多个线程访问一个类时, 如果不用考虑这些线程在运行时环境下的调度和交替执行, 并且不需要额外的
    同步及在调度方代码不必做其他的协调, 这个类的行为仍然是正确的, 那么称这个类是 线程安全的.

servlet 无状态性: 不包含域也没有引用其他类的域. 一个特定计算的瞬时状态, 会唯一地存在本地变量中, 这些本地变量存储
    在线程的栈中, 只有执行线程才能访问.
无状态对象永远是线程安全的.


volatile 的应用：
    1. 禁止指令的重排序优化(保证有序性);
    2. 提供内存可见性: 对一个 volatile 变量的读, 总能看到(任意线程)对这个 volatile 变量最后的写入;
    3. 不保证原子性: 对任意单个 volatile 变量的 读/写 具有原子性, 但类似 volatile++ 这种复合操作不具有原子性.
 在多线程并发编程中 synchronized 和 volatile 都扮演者重要角色， volatile 是轻量级的 synchronized，
 它在多处理器开发中保证了 共享变量的 “可见性”。 可见性的意思是当一个线程修改一个共享变量时，另外一个线程
 能读到这个修改的值。如果 volatile 变量修饰符使用恰当的话，它比 synchronized 的使用和执行成本更低，因为
 它不会引起线程上下文的切换和调度。
java 语言规范第三版中对 volatile 的定义如下：java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和
一致地更新，线程应该确保通过排他锁单独获得这个变量。java 语言提供了 volatile，在某些情况下比锁要更加方便。
如果一个字段被声明成 volatile，java 线程内存模型确保所有线程看到这个变量的值是一致的。

volatile 与 synchronized
    1. volatile 关键字的作用就是强制从公共堆栈中取得变量的值, 而不是线程私有的数据栈中取得变量的值.
    2. volatile 是线程同步的轻量级实现, 性能比 synchronized 要好, 并且 volatile 只能修饰变量, 而 synchronized 可以
        修饰方法、代码块等.
    3. 多线程访问 volatile 不会发生阻塞, 而 synchronized 会发生阻塞.
    4. 可以保证数据的可见性, 但不可以抱枕原子性, 而 synchronized 可以保证原子性, 也可以间接保证可见性, 因为它会将
        私有内存和公共内存中共的数据做同步.
    5. volatile 解决的是变量在多个线程之间的可见性, 而 synchronized 解决的是多个线程之间访问资源的同步性.


相关的 CPU 术语
内存屏障         -- memory barriers           -- 一组处理器指令，用于实现对内存操作的顺序限制。
缓冲行           -- cache line                -- 缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期。
原子操作         -- atomic operations         -- 不可中断的一个或一些列操作。
缓存行填充       -- cache line fill           -- 当处理器识别到从内存中读取操作是可缓存的，处理器读取整个缓存行到适当的缓存(L1, L2, L3 的或所有)。
缓存命中         -- cache hit                 -- 如果进行高速缓存填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取。
写命中           -- write hit                 -- 当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中。如果存在一个有效的缓存行，
                                                 则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为 写命中。
写缺失           -- write misses the cache    -- 一个有效的缓存行被写入到不存在的内存区域。

volatile 的实现原则：
 1. Lock 前缀指令会引起处理器缓存回写到内存。 Lock 前缀指令导致在执行指令期间，声言处理器的 LOCK# 信号。
    在多处理器环境中，LOCK# 信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK# 信号
    一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。。。。使用 “缓存一致性机制来确保修改的原子性”，此操作被称为 “缓存锁定”，
    缓存一致性 机制会阻止同时修改两个以上处理器缓存的内存区域数据。
 2. 一个处理器的缓存会写到内存会导致其他处理器的缓存无效。
    IA-32 处理器和 Intel 64 处理器使用 MESI(修改,独占,共享,无效)控制协议去维护内部缓存和其他处理器缓存的一致性。
    在多核处理器系统中进行操作的时候，IA-32 和 Intel 64 处理器能嗅探其他处理器访问系统内存和它们的内部缓存。处理器使用
    嗅探技术 保证它的内部缓存，系统内存和其他处理器的缓存数据在 总线上保持一致。例如，在 Pentium 和 P6 family 处理器中，如果通过
    嗅探一个处理器来检测其他处理器打算写内存地址，而这个地址当前处于共享状态，那么正在嗅探的处理器将使它的缓存行无效，在下次访问相同
    内存地址时，强制执行缓存行填充。

synchronized 会锁住总线，导致其他 CPU 不能访问总线，不能访问总线就意味着不能访问系统内存。
   “重量级锁”。java SE 1.6 对 synchronized 进行优化：为了减少 获得锁 和 释放锁 带来的性能消耗而引入的 偏向锁 和 轻量级锁，
   以及 锁的存储结构和升级过程。
基础：
 java 中的任一对象都可以作为 锁。具体表现在：
 1. 对于普通同步方法，锁是当前实例对象；
 2. 对于静态同步方法，锁是当前类的 Class 对象；
 3. 对于同步方法块，锁是 synchronized 括号里配置的对象。
 当一个线程视图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
 那么 锁 到底在哪里呢？锁里面会存储什么信息呢？
    从 JVM 规范中可以看到 synchronized 在 JVM 里的实现原里，JVM 基于进入和退出 Monitor 对象来实现 方法 同步和 代码块 同步，但两者的实现细节不一样。
    代码块同步 是使用 monitorenter 和 monitorexit 指令实现的，而同步方法是使用另外一种方式实现的，细节在 JVM 规范并没有详细说明。但是，方法的同步
    同样可以使用这两个指令来实现。
   monitorenter 指令是在编译后插入到 同步代码块 的开始位置， 而 monitorexit 指令插入到方法的结束外和异常外，JVM 要保证每个 monitorenter 必须有对应的
   monitorexit 与之配对。任何对象都有一个 monitor 与之关联，当一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令后，将会尝试获取
   对象所对应的 monitor 的所有权，即尝试获得对象的锁。
java 对象头
    synchronized 用的锁是存在 java 对象头里的。如果对象是数组类型，则虚拟机用 3 个字(word)宽存储对象头, 如果对象是非数组类型, 则用 2 字宽存储对象头.
    在 32 位虚拟机中, 1 字宽等于 4 个字节, 即 32 bit.

            java 对象头的长度
长度                      内容                              说明
32/64 bit               Mark Word                       存储对象的 hashCode 或锁信息等
32/64 bit               Class Metadata Address          存储到对象类型数据的指针
32/64 bit               Array Length                    数组的长度(如果当前对象是数组)

java 对象头里的 Mark Word 里默认存储对象的 HashCode, 分代年龄 和 锁标记位.
        32 位 JVM 的 Mark Word 的默认存储结构
锁状态         25 bit                  4 bit           1 bit 是否是偏向锁       2 bit 锁标志位
xxxx           对象的 hashCode        对象分代年龄            0                      01

在运行期间, Mark Word 里存储的数据会随着锁标志的变化而变化. Mark Word 可能变化为存储以下 4 种数据.
锁状态        |     25 bit             |     4 bit        |       1 bit           |        2 bit
              |  23 bit   |   2 bit    |                  |    是否是偏向锁       |       锁标志位
轻量级锁      |                     指向栈中锁记录的指针                           |         00
重量级锁      |                     指向互斥量(重量级锁)的指针                     |         10
GC 标记       |                       空                                          |         11
偏向锁        |  线程 ID  |   Epoch     | 对象分代年龄     |        1              |         01

在 64 位虚拟机下, Mark Word 是 64 bit 大小的, 其存储结构如表:
锁状态         25 bit          31 bit           1 bit              4 bit           1 bit               2 bit
                                               cms_free          分代年龄          偏向锁              锁标志位
无锁           unused         hashCode                                                0                  01
偏向锁         ThreadID(54 bit) Epoch(2 bit)                                          1                  01

锁的升级对比:
 java SE 1.6 为了减少获得锁和释放锁带来的性能消耗, 引入了 "偏向锁" 和 "轻量级锁", 在 Java SE 1.6 中, 锁 共有 4 种状态,
 级别从低到高依次是: 无锁状态, 偏向锁状态, 轻量级锁状态, 重量级锁状态. 这几个状态会随着竞争情况逐渐升级, 锁可以升级但不能降级,
 意味着 偏向锁 升级成 轻量级锁 后不能降级为 偏向锁. 这种 锁 升级不能降级的策略, 目的是为了提高 获得锁和释放锁 的效率.

1. 偏向锁.
   HotSpot 的作者经过研究发现, 大多数情况下, 锁 不仅不存在 多线程竞争, 而且总是由同一线程多次获得, 为了让线程获得锁的代价更低
   而引入了偏向锁. 当一个线程访问同步块并获取锁时, 会在 对象头 和 栈帧 中的锁记录里存储锁偏向的线程 ID, 以后该线程在进入和退出
   同步块时不需要进行 CAS 操作来加锁和解锁, 只需简单地测试以下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁.
   如果测试成功, 表示线程已经获得了锁. 如果测试失败, 则需要再测试一下 Mark Word 中偏向锁的标识是否设置成 1(表示当前是偏向锁):
   如果没有设置, 则使用 CAS 竞争锁; 如果设置了, 则尝试使用 CAS 将对象头的偏向锁指向当前线程.
   1.1. 偏向锁的撤销
    偏向锁使用了一种等到竞争出现才释放锁的机制, 所以当其他线程尝试竞争偏向锁时, 持有偏向锁的线程才会释放锁. 偏向锁的撤销,
    需要等待全局安全点(在这个时间点上没有正在执行的字节码). 它会首先暂停拥有偏向锁的线程, 然后检查持有偏向锁的线程是否活着,
    如果线程不处在活动状态, 则将对象头设置成无锁状态; 如果线程仍然活着, 拥有偏向锁的栈会被执行, 遍历偏向对象的锁记录, 栈中的锁记录和
    对象头的 Mark Word 要么重新偏向于其他线程, 要么恢复到无锁或者 标记对象不适合作为偏向锁, 最后唤醒暂停的线程.
   1.2. 关闭偏向锁
    偏向锁在 java 6 和 java 7 里是默认启动的, 但是它在应用程序启动几秒钟之后才激活, 如果有必要可以使用 JVM 参数来关闭延迟
    -XX:BiasedLockingStartupDelay=0. 如果你确定应用程序里所有的锁通常情况下处于竞争状态, 可以通过 JVM 参数关闭偏向锁
    -XX:-UseBiasedLocking=false, 那么程序默认会进入轻量级锁状态.
2. 轻量级锁.
   2.1. 轻量级锁加锁
    线程在执行同步块之前, JVM 会先在当前线程的栈帧中创建用于存储锁记录的空间, 并将对象头中的 Mark Word 赋值到锁记录中, 官方称
    Displaced Mark Word. 然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针. 如果成功, 当前线程获得锁, 如果失败,
    表示其他线程竞争锁, 当前线程便尝试使用自旋来获取锁.
   2.2. 轻量级锁解锁
    轻量级解锁时, 会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头, 如果成功, 则表示没有竞争发生. 如果失败, 表示当前锁存在
    竞争, 锁就会膨胀称重量级锁.
   因为自旋会消耗 CPU, 为了避免无用的自旋(比如获得锁的线程被阻塞住了), 一旦锁升级成重量级锁, 就不会再恢复到轻量级锁状态.
   当锁处于这个状态下, 其他线程视图获取锁时, 都会被阻塞住, 当持有锁的线程被释放之后会唤醒这些线程, 被唤醒的线程就会进行新一轮的夺锁之争.

                            锁的优缺点对比
锁                   优点                                          缺点                          适用场景
偏向锁           加锁和解锁不需要额外的消耗,                 如果线程间存在锁竞争,会带来         适用于只有一个线程访问同步块场景
              和执行非同步方法相比仅存在纳秒级的差距         额外的锁撤销的消耗
轻量级锁      竞争的线程不会阻塞, 提高了程序的响应速度        如果始终得不到锁竞争的线程,         追求响应时间, 同步块执行速度非常快
                                                            使用自旋会消耗 CPU
重量级锁      线程竞争不使用自旋, 不会消耗 CPU               线程阻塞, 响应时间缓慢              追求吞吐量, 同步块执行时间较长

原子操作的实现原理
   原子(atomic) 本意是 "不能被进行分割的最小粒子", 而原子操作(atomic operation) 意为 "不可被中断的一个或一系列操作".
   在多处理器上实现原子操作就变得有点复杂.
        相关 CPU 术语
术语名称                    英文                      解释
缓存行                     cache line                 缓存的最小操作单位
比较并交换                 compare and swap           CAS 操作需要输入两个数值, 一个旧值(期望操作前的值)和一个新值, 在操作期间先比较旧值有没发生变化,
                                                     如果没有发生变化, 才叫换成新值, 发生变化则不交换.
CPU 流水线                 CPU pipeline              CPU 流水线的工作方式就像工业生产上的装配流水线, 在 CPU 中由 5~6 个不同功能的电路单元组成一条
                                                     指令处理流水线, 然后将一条 X86 指令分成 5~6 步后再由这些电路单元分别执行, 这样就能实现一个 CPU
                                                     时钟周期完成一条指令, 因此提高 CPU 的运算速度.
内存顺序冲突              Memory order violation      内存顺序冲突一般是由假共享引起的, 假共享是指多个 CPU 同时修改同一个缓存行的不同部分而引起其中一个
                                                     CPU 的操作无效, 当出现这个内存顺序冲突时, CPU 必须清空流水线.

处理器如何实现原子操作:
   32 位 IA-32 处理器使用基于对 缓存加锁 或 总线加锁 的方式来实现多处理器之间的原子操作. 首先处理器会自动保证基本的内存操作的原子性.
   处理器保证从系统内存中读取或者写入一个字节是原子的, 意思是当一个处理器读取一个字节时, 其他处理器不能访问这个字节的内存地址.
   Pentium 6 和最新的处理器能自动保证单处理器对同一个缓存行里进行 16/32/64 位的操作是原子的, 但是复杂的内存操作处理器是不能
   自动保证其原子性的, 比如跨总线宽度, 跨多个缓存行和跨页表的访问. 但是, 处理器提供 总线锁定 和 缓存锁定 两个机制来保证复杂内存操作的原子性.
   1. 使用 总线锁 保证原子性
     第一个机制是通过 总线锁 保证原子性. 如果多个处理器同时对共享变量进行 读写改 操作(i++ 就是经典的读改写操作), 那么共享变量就会被多个处理器
     同时进行操作, 这样 读写改 操作就不是原子的, 操作完之后共享变量的值会和期望的不一致.
     想要保证 读写改 共享变量的操作是原子的, 就必须保证 CPU1 读写改 共享变量的时候, CPU2 不能操作缓存了该共享变量内存地址的缓存.
     处理使用 总线锁 就是来解决此问题的. 所谓 总线锁 就是使用处理器提供的一个 LOCK# 信号, 当一个处理器在总线上输出此信号时, 其他处理器的请求
     将被阻塞住, 那么该处理器可以独占共享内存.
   2. 使用 缓存锁 保证原子性
     第二个机制是通过缓存锁定来保证原子性. 在同一时刻, 我们只需保证对某个内存地址的操作是原子性即可, 但总线锁定把 CPU 和内存之间的通信锁住了,
     这使得 锁定期间, 其他处理器不能操作其他内存地址的数据, 所以总线锁定的开销比较大, 目前处理器在某些场合下使用 缓存锁定 替代总线锁定来进行优化.
    频繁使用的内存会缓存在处理器的 L1, L2 和 L3 高速缓存里, 那么原子操作就可以直接在处理器内部缓存中进行, 并不需要声明 总线锁, 在 Pentium 6 和目前
    的处理器中可以使用 "缓存锁定" 的方式来实现复杂的原子性.
    所谓 "缓存锁定" 是指内存区域如果被缓存在处理器的缓存行中, 并且在 Lock 操作期间被锁定, 那么当它执行锁操作回写到内存时, 处理器不在总线上声言 LOCK#
    信号, 而是修改内部的内存地址, 并允许它的缓存一致性机制来保证操作的原子性, 因为 缓存一致性机制会组织同时修改由两个以上处理器缓存的内存区域数据,
    当其他处理器回写已被锁定的缓存行的数据时, 会使缓存行无效.
但是有两种情况下处理器不会使用缓存锁定:
  condition 1. 当操作的数据不能被缓存在处理器内部, 或操作的数据跨多个缓存行(cache line)时, 则处理器会调用总线锁定.
  condition 2. 有些处理器不支持缓存锁定. 对于 Intel 486 和 Pentium 处理器, 就算锁定的内存区域在处理器的缓存行中也会调用总线锁定.
  针对以上两个机制, 我们通过 Intel 处理器提供了很多 Lock 前缀的指令来实现. 例如, 位测试和修改指: BTS, BTR, BTR; 交换指令 XADD, CMPXCHG,
  以及其他一些操作数和逻辑指令(如 ADD, OR)等, 被这些指令操作的内存区域就会加锁, 导致其他处理器不能同时访问它.

Java 如何实现原子操作.
    java 中通过 锁 和 循环 CAS 的方式来实现原子操作.
  1. 使用 循环 CAS 实现原子操作.
    JVM 中的 CAS 操作正是利用了处理器提供的 CMPXCHG 指令实现的. 自旋 CAS 实现的基本思路就是循环进行 CAS 操作直到
    成功为止. 以下代码实现了一个基于 CAS 线程安全的计数器方法 safe count 和一个非线程安全的计数器 count.
------------------------------------------------------------------------------------------------------------------------
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * ~~ Talk is cheap. Show me the code. ~~ :-)
 *
 * @author MiaoOne
 * @since 2019/12/20 9:22
 */
public class ConcurrentTest {
    private AtomicInteger i = new AtomicInteger(0);

    private int a = 0;

    public static void main(String[] args) {
        final ConcurrentTest cas = new ConcurrentTest();
        List<Thread> ts = new ArrayList<>(600);

        long start = System.currentTimeMillis();

        for (int i = 0; i < 100; i++) {
            Thread t = new Thread(() -> {
                for (int j = 0; j < 1000; j++) {
                    cas.count();
                    cas.safeCount();
                }
            });
            ts.add(t);
        }
        ts.forEach(Thread::start);

        // 等待所有线程执行完毕.
        ts.forEach(thread -> {
            try {
                thread.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        System.out.println(cas.a);
        System.out.println(cas.i.get());
        System.out.println(System.currentTimeMillis() - start + "ms");
    }

    /* 使用 CAS 实现线程安全计数器. */
    private void safeCount() {
        for (; ; ) {
            int a = this.i.get();
            boolean suc = this.i.compareAndSet(a, ++a);
            if (suc) {
                break;
            }
        }
    }

    /* 非线程安全计数器. */
    private void count() {
        a++;
    }
}
------------------------------------------------------------------------------------------------------------------------

CAS 实现原子操作的三大问题
   JUC 包中有一些并发框架也使用了自旋 CAS 的方式来实现原子操作, 比如 {@code java.util.concurrent.LinkedTransferQueue}
   的 {java.util.concurrent.LinkedTransferQueue.xfer()} 方法. CAS 虽然很高效地解决了原子操作, 但是 CAS 仍然存在三大问题.
   ABA 问题, 循环时间长开销大, 以及只能保证一个共享变量的源自操作.
   1. ABA 问题.
     因为 CAS 需要在操作值的时候, 检查值有没有发生变化, 如果没有发生变化, 但是如果一个值原来是 A, 变成了 B, 又变成了 A, 那么使用 CAS
     进行检查时会发现它的值没有发生变化, 但是实际上发生了变化. ABA 问题的解决思路就是使用版本号. 在变量前面追加上版本号, 每次变量更新的
     时候把版本号加 1, 那么 A->B->A 就会变成 1A->2B->3A. 从 java 1.5 开始, JDK 的 Atomic 包里提供了一个类 {java.util.concurrent.atomic.AtomicStampedReference}
     来解决 ABA 问题. 这个类的 compareAndSet 方法的作用是首先检查当前引用是否等于预期引用, 并且检查当前标志是否等于预期标志, 如果全部相等,
     则以原子方式将该引用和该标志的值设置为给定的更新值.
     java.util.concurrent.atomic.AtomicStampedReference.compareAndSet(V   expectedReference, // 预期引用.
                                                                      V   newReference, // 更新后的引用.
                                                                      int expectedStamp, // 预期标志.
                                                                      int newStamp) // 更新后的标志.
   2. 循环时间长开销大.
      自旋 CAS 如果长时间不成功, 会给 CPU 带来非常大的执行开销. 如果 JVM 能支持处理器提供的 pause 指令, 那么效率会有一定的提升.
      pause 指令有两个作用: 第一, 它可以延迟流水线执行指令(de-pipeline), 使 CPU 不会消耗过多的执行资源, 延迟的时间取决于具体实现的版本




