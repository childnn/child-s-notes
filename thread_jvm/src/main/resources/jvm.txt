    深入理解 Java 虚拟机
程序计数器: Program Counter Register
    一块较小的内存空间, 它可以看作是当前线程所执行的字节码的行号指示器.
    在虚拟机的概念模型里(仅是概念模型, 各种虚拟机可能会通过一些更高效的方式去实现),
    字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,
    分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的,
    在任何一个确定的时刻, 一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的
    指令. 因此, 为了线程切换后能回复到正确的执行位置, 每条线程都需要有一个独立的
    程序计数器, 各条线程之间计数器互不影响, 独立存储, 称这类内存区域为 "线程私有" 的内存.
    如果线程正在执行的是一个 Java 方法, 这个计数器记录的是正在执行的虚拟机字节码指令
    的地址: 如果正在执行的是 Native 方法, 这个计数器值则为空(Undefined).
    此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域.
Java 虚拟机栈: Java Virtual Machine Stacks
    与程序计数器一样, Java 虚拟机栈也是线程私有的, 它的生命周期与线程相同. 虚拟机栈描述
    的是 Java 方法执行的内存模型: 每个方法在执行的同时都会创建一个栈帧(Stack Frame) 用于存储
    局部变量表、操作数栈、动态连接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着
    一个栈帧在虚拟机中入栈到出栈的过程。
    局部变量表存放了编译器可知的各种基本数据类型, 对象引用, returnAddress 类型(指向了一条字节码指令的地址).
    在 Java 虚拟机规范中, 对这个区域规定了两种异常状况: 如果线程请求的栈深度大于虚拟机所允许的深度,
    将抛出 StackOverflowError 异常: 如果虚拟机栈可以动态扩展(当前大部分的 Java 虚拟机都可动态扩展,
    只不过Java 虚拟机规范中也允许固定长度的虚拟机栈), 如果扩展时无法申请到足够的内存, 就会抛出 OutOfMemoryError 异常.
本地方法栈: Native Method Stack
    与虚拟机栈所发挥的作用非常相似, 区别不过是 虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务, 而本地方法栈
    为虚拟机使用的 Native 方法服务.
Java 堆: Java Heap
    Java 堆是 Java 虚拟机所管理的内存中最大的一块. Java 堆是被所有线程共享的一块内存区域, 在虚拟机启动时创建.
    此区域的唯一目的就是存放对象实例, 几乎所有的对象实例都在这里分配内存. 这一点在 Java 虚拟机规范中的描述是:
    所有的对象实例以及数组都要在堆上分配-- The heap is the runtime data area from which memory for all class
    instances and arrays is allocate.
    Java 堆是垃圾收集器管理的主要区域, 因此很多时候也被称作 "GC 堆"(Garbage Collated Heap).
    从内存分配的角度来看, 线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB).
    通过 -Xmx 和 -Xms 控制堆空间, 如果在堆中没有内存完成实例分配, 并且堆也无法在扩展时, 将会抛出 OutOfMemoryError 异常.
方法区 Method Area
    与 Java 堆一样, 是各个线程共享的内存区域, 它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码等数据。
     "java.lang.OutOfMemoryError: PermGen space ", 这里的 “PermGen space”其实指的就是方法区。
     不过方法区和“PermGen space”又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，
     并且只有 HotSpot 才有 “PermGen space”，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM）
     并没有“PermGen space”。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。
     在 JDK 1.8 中， HotSpot 已经没有 “PermGen space”这个区间了，取而代之是一个叫做 Metaspace（元空间）.
     JDK 1.7 和 1.8 将字符串常量由永久代转移到堆中.
     元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
     因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：
     　　-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：
            如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。
     　　-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
     　　除了上面两个指定大小的选项以外，还有两个与 GC 相关的属性：
     　　-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
     　　-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集
     由 方法区 到 原空间转换的理由:
         1、字符串存在永久代中，容易出现性能问题和内存溢出。
     　　2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
     　　3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
     　　4、Oracle 可能会将HotSpot 与 JRockit 合二为一。
     HotSpot 虚拟机的设计团队选择把 GC 分代扩展至方法区, 或者说使用永久代来实现方法区, 这样 HotSpot 的垃圾收集器可以像
     管理 Java 堆一样管理这部分内存, 能够省去专门为方法区编写内存管理代码的工作.
运行时常量池: Runtime Constant Pool
    方法区的一部分. Class 文件中除了有类的版本、字段、方法、接口等描述信息外, 还有一项信息是常量池, 用于存放编译期生成的
    各种字面量和符号引用, 这部分内容将在类加载后进入方法区的运行时常量池中存放.
    运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备动态性, Java 语言并不要求常量一定只有编译期才能产生,
    也就是并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池, 运行期间也可能将新的常量放入池中, 这种特性被
    开发人员利用的比较多的便是 String 类的 intern() 方法.
直接内存: Direct Memory
    并不是虚拟机运行时数据区的一部分, 也不是 Java 虚拟机规范中定义的内存区域. 但是这部分内存也被频繁地使用, 而且也可能导致
    OOM 异常的出现.
    JDK 1.4 中引入的 NIO, 有一种基于通道 Channel 与缓冲区 Buffer 的 I/O 方式, 它可以使用 Native 函数库直接分配堆外内存,
    然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作. 这样能在一些场景中显著提高性能,
    因为避免了在 Java 堆和 Native 堆中来回复制数据.

程序计数器, 虚拟机栈, 本地方法栈 3 个区域随着线程而生/灭.
这几个区域内不需要过多考虑回收的问题, 因为方法或者线程结束时, 内存自然就回收了.
Java 堆和方法区则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支
则不一样, 一个接口中的多个实现类需要的内存可能不一样, 一个方法中的多个分支需要的内存
也可能不一样, 只有在程序运行期间才能知道会创建哪些对象, 这部分内存的分配和回收都是动态的, 垃圾收集器所关注
的是这部分内存.

判断对象是否存活: 引用计数算法, 可达性分析算法
垃圾收集算法: 标记-清除算法, 复制算法, 标记-整理算法, 分代收集算法
 标记-清除: Mark-Sweeping
    算法分为 "标记", "清除" 两个阶段: 首先标记处所有需要回收的对象, 在标记完成后同意回收所有被标记的对象,
    它的标记过程其实就是判定对象的引用问题(可达性分析算法). 它主要有两个不足点: 一个是效率问题, 标记和清除
    两个过程的效率都不高; 另一个是空间问题, 标记清楚后会产生大量不连续的内存碎片, 空间碎片大多可能会导致以后
    在程序运行过程中需要分配较大对象时, 无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作.
 复制算法: Copying
    为了解决效率问题, 复制收集算法出现, 它将可用内存按容量划分为大小相等的两块, 每次使用其中一块. 当这一块内存用完了,
    就将还存活的对象复制到另一块上, 然后再把已使用过的内存空间一次清理掉. 这样使得每次都是对整个半区进行内存回收,
    内存分配时也就不用考虑内存碎片等复杂情况, 只要移动堆顶指针, 按顺序分配内存即可, 实现简单, 运行高效.
    只是这种算法的代价是将内存缩小为原来的一半.
