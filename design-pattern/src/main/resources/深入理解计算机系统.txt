系统的硬件组成:
1. 总线.
   贯穿整个系统的是一组电子管道, 称总线.
   它携带信息字节并负责在各个部件间传递. 通常总线被设计成传送定长的字节块, 也就是 字(word).
   字中的字节数(即字长)是一个基本的系统参数, 各个系统中都不尽相同. 现在的大多数机器字长要么是 4 个字节(32位),
   要么是 8 个字节(64位).
2. I/O 设备.
    I/O 设备是系统与外部世界的联系通道. 我们的示例系统包括四个 I/O 设备: 作为用户输入的键盘和鼠标, 作为用户输出的显示器,
    以及用于长期存储数据和程序的磁盘驱动器(磁盘).
    每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连. 控制器和适配器之间的区别在于它们的封装方式.
    控制器 是 I/O 设备本身或者系统的主印制电路板(主板)上的芯片组.
    适配器 是一块插在主板插槽上的卡.
    它们的功能都是在 I/O 总线和 I/O 设备之间传递信息.
3. 主存.
    主存是一个临时存储设备, 在处理器执行程序时, 用来存放程序和程序处理的数据.
    从物理上来说, 主存是一组 动态随机存取存储器(DRAM)芯片组成的.
    从逻辑上来说, 存储器是一个线性的字节数组, 每个字节都有其唯一的地址(数组索引), 这些地址是从零开始的.
4. 处理器.
    中央处理单元 CPU, 简称处理器, 是解释(或执行)存储在主存中指令的引擎.
    处理器的核心是一个大小为一个字的存储设备(或寄存器), 称为 程序计数器(PC).
    在任何时刻, PC 都指向主存中的某条机器语言指令(即含有该条指令的地址).
    从系统通电开始, 直到系统断电, 处理器一直在不断地执行 程序计数器 指向 地指令, 再更新程序计数器, 使其指向下一条指令.
    处理器 看上去是按照一个非常简单地指令执行模型来操作的, 这个模型是由指令集架构决定的.
    在这个模型中, 指令按照严格的顺序执行, 而执行一条指令包含执行一系列的步骤. 处理器从程序计数器指向的内存处读取指令,
    解释指令中的位, 执行该指令指示的简单操作, 然后更行 PC, 使其指向下一条指令, 而这条指令并不一定和在内存中刚刚执行的指令相邻.
    这样的简单操作并不多, 它们围绕着主存、寄存器文件(register file)和 算术/逻辑单元(ALU) 进行.
    寄存器文件 是一个小的存储设备, 由一些单个字长的寄存器组成, 每个寄存器都有唯一的名字. ALU 计算新的数据和地址值.
    下面是一些简单操作的例子, CPU 在指令的要求下可能会执行这些操作.
     -- 加载: 从主存复制一个字节或者一个字到寄存器, 以覆盖寄存器原来的内容.
     -- 存储: 从寄存器复制一个字节或者一个字到主存的某个位置, 以覆盖这个位置上原来的内容.
     -- 操作: 把两个寄存器的内容复制到 ALU, ALU 对这两个做算术运算, 并将结果存放到一个寄存器中, 以覆盖该寄存器中原来的内容.
     -- 跳转: 从指令本身中抽取一个字, 并将这个字复制到程序计数器(PC)中, 以覆盖 PC 中原来的值.
     处理器 看上去是它的指令集架构的简单实现, 但是实际上现代处理器使用了非常复杂的机制来加速程序的执行. 因此, 我们将处理器的指令集
     架构和处理器的微体系结构区分开来: 指令集架构 描述的是每条机器代码指令的效果; 而 微体系结构 描述的是处理器实际上是如何实现的.

文件.
-- 文件就是字节序列, 仅此而已. 每个 I/O 设备, 包括 磁盘、键盘、显示器, 甚至网络, 都可以看成是 文件.
   系统中的所有输入输出都是通过使用一个小组成为 Unix I/O 的系统函数调用读写文件来实现的.
   文件 这个简单而精致的概念是非常强大的, 因为它向应用程序提供了一个统一的视图, 来看待系统中可能含有的所有各式各样的 I/O 设备.

:-)

Amdahl 定律. Gene Amdahl. Amdahl's law. 阿姆达尔定律.
-- 该定律的主要思想是, 当我们对系统的某个部分加速时, 其对系统整体性能的影响取决于该部分的重要性和加速程度.
   若系统执行某应用程序需要时间位 T(old). 假设系统某部分所需执行时间与该时间的比例位 α, 而该部分性能提升比例位 k.
   即该部分初始所需时间位 αT(old), 现在所需时间为 (αT(old))/k. 因此, 总的执行时间应为:
    T(new) = (1 - α)T(old) + (αT(old))/k = T(old)[(1 - α) + α/k]
    -- 由此, 可以计算加速度比 S = T(old)/T(new) 为
       S = 1/((1 - α) + α/k)
  eg: 系统的某个部分初始耗时比例为 60%(α = 0.6), 其加速比例因子为 3(k = 3). 则我们可以获得的加速比为 1/[0.4 + 0.6/3] = 1.67 倍.
    虽然我们对系统的一个主要部分做出了重大改进, 但是获得的系统加速比却明显小于这部分的加速比.
    这就是 Amdahl 定律的主要观点 -- 想要显著加速整个系统, 必须提升全系统中相当大的部分的速度.

并行和并发
-- 数字计算机的整个历史中, 有两个需求是驱动进步的持续动力: 一个是我们想要计算机做得更多, 另一个是我们想要计算机运行得更快.
   当处理器能够同时做更多的事情时, 这两个因素都会改进.
   并发 concurrency: 指一个同时具有多个活动的系统;
   并行 parallelism: 指用并发来使一个系统运行得更快.
-- 按照系统层次结构中由高到低得顺序重点强调三个层次:
   1. 线程级并发
       构建在 进程 这个抽象之上, 我们能够设计出同时有多个程序执行的系统, 这就导致了 并发. 使用 线程, 我们甚至能够
       在一个 进程 中执行多个 控制流.
       传统意义上, 这种 并发执行 只是 模拟 出来的, 是通过使一台计算机在它正在执行的 进程 间快速切换来实现的, 就好像
       一个杂耍艺人保持多个球在空中飞舞一样. 这种 并发 形式允许多个用户同时与系统交互, 例如, 当许多人想要从一个 Web 服务器
       获取页面时. 它还允许一个用户同时从十多个任务, 例如, 在一个窗口中开启 Web 浏览器, 在另一个窗口中运行字处理器,
       同时又播放音乐. 在以前, 即使处理器必须在多个任务间切换, 大多数实际的计算也都是由一个处理器来完成的. 这种配置称为
       单处理器系统.
   当构建一个由 单操作系统内核 控制的 多处理器 组成的系统时, 我们得到了一个 多处理器系统.
   -- 多处理器系统 包括 多核, 超线程(hyperthreading).
       -- 多核处理器 将多个 CPU(称为"核") 集成到一个集成到电路芯片上. 每个核都有自己的 L1 和 L2 高速缓存, 其中 L1 告诉缓存分为
          两个部分 -- 一个保存最近去到的指令, 另一个存放数据. 这些核共享更高层次的告诉缓存, 以及到主存的接口.
       -- 超线程, 有时称为 同时多线程(simultaneous multi-threading), 是一项允许一个 CPU 执行多个控制流的技术.
          它涉及 CPU 某些硬件有多个备份, 比如 程序计数器 和 寄存器文件, 而其他的硬件部分只有一份, 比如执行浮点算术运算的单元.
          常规的处理器需要大约 20,000 个时钟周期做不同线程间的转换, 而超线程的处理器可以在单个周期的基础上决定要执行哪个线程.
          这使得 CPU 能够更好地利用它地处理资源. 比如, 假设一个线程必须等到某些数据被装载到高速缓存中, 那 CPU 就可以继续去执行另一个线程.
          eg: Intel Core i7 处理器可以让每个核执行两个线程, 所以一个 4 核的系统实际上可以并行地执行 8 个线程.
       多处理器 的使用可以从两方面提高系统性能.
       首先, 它减少了在执行多个任务时模拟并发的需要. 正如前述, 即使是只有一个用户使用的个人计算机也需要并发地执行多个活动.
       其次, 它可以使应用程序运行得更快, 当然, 这必须要求程序是以多线程方式来书写的, 这些线程可以并行地高效执行.
   2. 指令级并行
       在较低的抽象层次上, 现代处理器可以同时执行多条指令的属性称为 指令级并行.
       如果处理器可以达到比一个周期一条指令更快的执行效率, 就称为 超标量(super-scalar)处理器.
   3. 单指令、多数据并行
       在最低层次上, 许多现代处理器拥有特殊的硬件, 允许一条指令产生多个可以并行执行的操作, 这种方式称为 单指令、多数据,
       即 SIMD 并行.

抽象: 计算机系统中的一个重大主题就是提供不同层次的抽象表示, 来隐藏实际实现的复杂性.
    1. 文件 是对 I/O 设备的抽象.
    2. 虚拟内存 是对 程序存储器(主存 和 磁盘) 的抽象.
    3. 指令集架构 是对 处理器硬件的抽象. 使用这个抽象, 机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上.
    3. 进程 是对一个正在运行的程序的抽象 -- 包括 (处理器+主存+I/O设备).
    4. 虚拟机 是对整个计算机的抽象, 包括操作系统、处理器和程序.
---
计算机系统由硬件和系统软件组成, 它们共同协作以运行应用程序. 计算机内部的信息被表示为一组组的为, 它们依据上下文有不同的解释方式.
程序被其他程序翻译成不同的形式, 开始时是 ASCII 文本, 然后被 编译器 和 链接器 翻译成二进制可执行文件.
处理器 读取并解释存放在主存里得二进制指令. 因为计算机花费大量得时间在内存、I/O 设备和 CPU 寄存器之间复制数据, 所以将系统中的存储设备
划分成层次结构 -- CPU 寄存器在顶部, 接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器.
---
现代计算机存储和处理的信息以二值信号表示. 这些微不足道的二进制数字, 或者称为 位(bit), 形成了数字革命的基础.
孤立地讲, 单个的位不是非常有用. 然而, 当把位组合在一起, 再加上某种解释(interpretation), 即赋予不同的可能位模式以含意,
我们就能表示任何有限集合的元素.
数字的表示:
-- 无符号(unsigned)编码: 基于传统的二进制表示法, 表示大于或者等于零的数字.
-- 补码(two's-complement)编码: 表示有符号整数的最常见的方式, 有符号整数就是可以为正或者为负的数字.
-- 浮点数(floating-point)编码是表示实数的科学计数法的以 2 为基数的版本.

反汇编器: disassembler.

逻辑符号:
^: 异或, exclusive-or. 当二者有真且不同时为真时, 结果为真.



